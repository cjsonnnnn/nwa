pipeline {
  agent { label 'agent-azure-net' }

  tools {
    jfrog 'jfrog-cli'
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    skipDefaultCheckout(true)
  }

  parameters {
    string(name: 'MAJOR_VERSION', defaultValue: '1', description: 'Major version')
    string(name: 'MINOR_VERSION', defaultValue: '1', description: 'Minor version')
    string(name: 'PATCH', defaultValue: '', description: 'Optional patch override')
  }

  environment {
    APP_NAME = "nwa"
    DOCKERHUB_REPO = "jpiay/${APP_NAME}"
    COMPONENT = "reporting-service"
  }

  stages {
    stage('Prepare Version') {
      steps {
        script {
          def major = params.MAJOR_VERSION
          def minor = params.MINOR_VERSION
          def patch = 0

          if (params.PATCH?.trim()) {
            // Use manual input
            patch = params.PATCH.toInteger()
            echo "Using manually provided patch version: ${patch}"
          } else {
            // Auto-increment based on previous build's display name (e.g., "1.2.3")
            def lastBuild = currentBuild.rawBuild.getPreviousSuccessfulBuild()
            if (lastBuild != null) {
              def lastName = lastBuild.getDisplayName()
              def matcher = lastName =~ /^(\d+)\.(\d+)\.(\d+)$/
              if (matcher.matches()) {
                patch = matcher[0][3].toInteger() + 1
                echo "Auto-incremented patch from last build: ${patch}"
              } else {
                patch = 1
                echo "Previous build name didn't match version pattern, starting from patch: ${patch}"
              }
            } else {
              patch = 1
              echo "No previous build found, starting from patch: ${patch}"
            }
          }

          env.PATCH = patch.toString()
          env.FULL_VERSION = "${major}.${minor}.${patch}"
          env.IMAGE_TAG = "${env.FULL_VERSION}"
          echo "Resolved version: ${env.FULL_VERSION}"
          currentBuild.displayName = "${env.FULL_VERSION}"
        }
      }
    }

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build and Dockerize') {
      steps {
        sh "dotnet restore"
        sh "dotnet publish -c Release -o publish"

        // Build Docker image
        sh """
          docker build -t ${DOCKERHUB_REPO}:${IMAGE_TAG} -t ${DOCKERHUB_REPO}:latest .
        """

        // Report the build and its produced artifact
        script {
          reportBuild(
            applicationName: env.APP_NAME,
            applicationVersion: IMAGE_TAG,
            applicationComponent: env.COMPONENT,
            artifactFileName: env.APP_NAME,
            artifactFileSizeLimit: 50 * 1024 * 1024
          )
        }
      }
    }

    stage('Docker Hub Login & Push') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub-jpiay', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh "echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin"

          // Push both versioned and latest tags
          sh """
            docker push ${DOCKERHUB_REPO}:${IMAGE_TAG}
            docker push ${DOCKERHUB_REPO}:latest
          """
        }
      }
    }

    stage('Report Release') {
      steps {
        script {
          reportArtifactRelease(
            applicationName: env.APP_NAME,
            applicationVersion: env.FULL_VERSION,
            applicationComponent: env.COMPONENT,
            repositoryName: 'Docker Hub',
            artifactName: "${env.DOCKERHUB_REPO}:${env.IMAGE_TAG}",
            tags: env.IMAGE_TAG,
            artifactURL: "https://hub.docker.com/r/${env.DOCKERHUB_REPO}"
          )
        }
      }
    }
  }
}
